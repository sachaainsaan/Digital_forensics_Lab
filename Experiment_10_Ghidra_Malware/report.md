# Experiment 10 — Ghidra (Malware Reverse Engineering)

**Aim:**  
To perform static reverse engineering of a malware sample using Ghidra to identify behavior, extracted strings, control flow, and potential indicators of compromise (IOCs).

---

## Tools Used
- **Tool Name:** Ghidra
- **Version:** 11.4.2 
- **Operating System:** Windows 11
- **Sample File Type:** `malware_sample.exe` (PE) / `malware_sample.bin`   
- **Output Type:** Decompiled code, function list, extracted strings.

---

## Safety Note
- Executed only **static analysis** — did not run the sample on the host.  
- Work performed in an isolated **VM / sandbox** environment.  
- Network access for the analysis VM was disabled (air-gapped) to prevent accidental execution/exfiltration.

---

## Procedure 
1. Prepared a **safe analysis environment**:
   - Used a snapshot of a VM (Windows or Linux) with networking disabled.  
   - Placed the malware sample in a dedicated analysis folder.
2. Launched **Ghidra** and created a **New Project** (Non-Shared Project).  
   - Project name: `Ghidra_Malware_Exp10`  
3. Imported the malware binary into the project:
   - **File → Import File** → `malware_sample.exe`  
   - Confirmed file format and accepted default loader settings.
4. Double-clicked the imported file to **open CodeBrowser** and allowed auto-analysis:
   - Selected default analysis options (function ID, decompiler, data type propagation).
5. Reviewed **Program Tree** and **Symbol Tree** to locate functions and entry point.
6. Opened the **Decompiler** window for the `main`/entry function to view high-level C-like pseudocode.
7. Searched for **suspicious strings**:
   - Menu: **Search → For Strings** or used `Strings` utility externally.
   - Noted URLs, domain names, registry keys, filenames, command lines, or suspicious commands.
8. Examined imported functions (Import Table) to identify API calls:
   - Looked for networking (`WinSock`), file I/O, process creation (`CreateProcess`, `ShellExecute`), registry (`RegOpenKeyEx`), and sleep/anti-debug APIs.
9. Traced control flow for suspicious functions:
   - Followed cross-references (Xrefs) to see how functions are called.
   - Renamed functions and variables as analysis progressed for readability.
10. Identified obfuscation or packer behavior (if present):
    - Checked entry stub for unpacking loops, large memory allocations, or calls to VirtualAlloc/VirtualProtect.
11. Extracted relevant IOCs:
    - Hard-coded IPs/domains, mutex names, file paths, registry keys, scheduled task names, persistence mechanisms.
12. Documented findings: function purpose, IOC list, suspicion level, and recommended mitigation.
13. Exported decompiled snippets and saved analysis session.
14. Cross-checked suspicious file hashes and strings on VirusTotal (without submitting the whole file if not allowed).

---

## Result / Observation
- Static analysis using Ghidra revealed networking routines and persistence attempts implemented through registry modification and file drop logic.  
- Extracted several IOCs (domains, mutex names, and file paths) that can be used for hunting or blocking.  
- No dynamic execution was performed; analysis relied on decompiled pseudocode, strings, and API imports.

---

## Conclusion
The experiment demonstrates effective static malware analysis with Ghidra: importing a binary, running auto-analysis, using the decompiler to understand high-level behavior, extracting strings and APIs, mapping control flow, and producing IOCs. Ghidra’s decompiler and navigation features enable a detailed understanding of suspected malware without executing it.

---

## Recommendations / Mitigation
1. Block identified domains and IPs at network perimeter (firewall/IDS).  
2. Add detected file hashes and IOCs to endpoint protection solutions.  
3. Remove persistence entries (Registry / Scheduled Tasks) on infected hosts after forensic imaging.  
4. If dynamic behavior must be observed, run the sample inside an isolated VM with network sinkhole and monitoring.

---

## Viva / Important Questions

1. **Why do we prefer static analysis before dynamic analysis?**  
→ Static analysis is safer (no execution), helps quickly find strings, APIs, and potential behavior; dynamic analysis follows when runtime behavior needs confirmation.

2. **What are indicators of packing or obfuscation?**  
→ Short unpacking stub, virtual memory allocation (VirtualAlloc), calls to VirtualProtect, unusual entropy, or many indirect calls.

3. **Which API calls are red flags for malware?**  
→ Networking (`send`, `connect`), process creation (`CreateProcess`), code injection/virtual memory APIs (`VirtualAlloc`, `WriteProcessMemory`), registry editing (`RegSetValueEx`).

4. **How do you extract useful IOCs from a binary?**  
→ Search for strings, inspect imports/exports, analyze config-like data structures in the binary, and follow function cross-references.

5. **What are the safety precautions when analyzing malware?**  
→ Use isolated VMs, disable network or route through controlled sinkholes, take snapshots, and avoid running samples on production systems.
